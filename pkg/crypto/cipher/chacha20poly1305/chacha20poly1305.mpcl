// -*- go -*-
//
// Copyright (c) 2021-2025 Markku Rossi
//
// All rights reserved.
//

// Package chacha20poly1305 implements the ChaCha20-Poly1305 AEAD, as
// specified in RFC 8439.
package chacha20poly1305

import (
	"bytes"
	"encoding/binary"
)

const (
	// KeySize specifies the key size in bytes.
	KeySize = 32

	// NonceSize specifies the nonce size in bytes.
	NonceSize = 12

	// TagSize specifies the tag size in bytes.
	TagSize = 16
)

//
// ===================== ChaCha20 core =====================
//

func add32(a, b uint32) uint32 {
	return a + b
}

func xor32(a, b uint32) uint32 {
	return a ^ b
}

func rotl32(x uint32, n uint32) uint32 {
	return (x << n) | (x >> (32 - n))
}

func quarterRound(s *[16]uint32, a, b, c, d int) {
	s[a] = add32(s[a], s[b])
	s[d] = rotl32(xor32(s[d], s[a]), 16)

	s[c] = add32(s[c], s[d])
	s[b] = rotl32(xor32(s[b], s[c]), 12)

	s[a] = add32(s[a], s[b])
	s[d] = rotl32(xor32(s[d], s[a]), 8)

	s[c] = add32(s[c], s[d])
	s[b] = rotl32(xor32(s[b], s[c]), 7)
}

// chacha20Block: key (32 bytes), counter (32-bit), nonce (12 bytes).
func chacha20Block(key [32]byte, counter uint32, nonce [12]byte) [64]byte {
	var state [16]uint32

	// Constants "expand 32-byte k"
	state[0] = 0x61707865
	state[1] = 0x3320646e
	state[2] = 0x79622d32
	state[3] = 0x6b206574

	// Key
	for i := 0; i < 8; i++ {
		state[4+i] = binary.GetUint32LSB(key[i*4 : (i+1)*4])
	}

	state[12] = counter

	// Nonce
	state[13] = binary.GetUint32LSB(nonce[0:4])
	state[14] = binary.GetUint32LSB(nonce[4:8])
	state[15] = binary.GetUint32LSB(nonce[8:12])

	working := state

	for i := 0; i < 10; i++ {
		// column
		quarterRound(&working, 0, 4, 8, 12)
		quarterRound(&working, 1, 5, 9, 13)
		quarterRound(&working, 2, 6, 10, 14)
		quarterRound(&working, 3, 7, 11, 15)
		// diagonal
		quarterRound(&working, 0, 5, 10, 15)
		quarterRound(&working, 1, 6, 11, 12)
		quarterRound(&working, 2, 7, 8, 13)
		quarterRound(&working, 3, 4, 9, 14)
	}

	for i := 0; i < 16; i++ {
		working[i] = add32(working[i], state[i])
	}

	var out [64]byte
	for i := 0; i < 16; i++ {
		out = binary.PutUint32LSB(out, i*4, working[i])
	}
	return out
}

func chacha20XOR(key [32]byte, nonce [12]byte, counter uint32,
	src []byte) []byte {

	dst := make([]byte, len(src))

	var block [64]byte
	var keystream []byte
	rem := len(src)
	sOff := 0
	dOff := 0
	c := counter

	for rem > 0 {
		block = chacha20Block(key, c, nonce)
		c++
		keystream = block[:]

		n := 64
		if rem < n {
			n = rem
		}

		for i := 0; i < n; i++ {
			dst[dOff+i] = src[sOff+i] ^ keystream[i]
		}

		rem -= n
		sOff += n
		dOff += n
	}

	return dst
}

//
// Helper: build Poly1305 input (AAD || pad || CT || pad || lens)
// For an MPC circuit you might instead hard-code max lengths and
// avoid this higher-level logic.
//

func buildPoly1305Msg(aad, ct []byte) []byte {
	aLen := len(aad)
	cLen := len(ct)

	p1 := paddingN(aLen, 16)
	p2 := paddingN(cLen, 16)

	total := aLen + p1 + cLen + p2 + 8 + 8
	out := make([]byte, total)

	ofs := copy(out, aad)
	ofs += p1
	ofs += copy(out[ofs:], ct)
	ofs += p2

	var lenBuf [8]byte

	lenBuf = binary.PutUint64LSB(lenBuf, 0, uint64(aLen))
	ofs += copy(out[ofs:], lenBuf)

	lenBuf = binary.PutUint64LSB(lenBuf, 0, uint64(cLen))
	ofs += copy(out[ofs:], lenBuf)

	return out
}

// poly1305TagBytes is a wrapper that processes arbitrary-length msg.
func poly1305TagBytes(msg, key []byte) [16]byte {
	if len(key) != 32 {
		panic("poly1305 key must be 32 bytes")
	}

	var st poly1305State
	var k [32]byte
	copy(k[:], key)
	poly1305Init(&st, k)

	var block [16]byte
	i := 0
	for i+16 <= len(msg) {
		copy(block[:], msg[i:i+16])
		poly1305Block(&st, &block)
		i += 16
	}

	// final partial block (if any)
	rem := len(msg) - i
	if rem > 0 {
		for j := 0; j < 16; j++ {
			if j < rem {
				block[j] = msg[i+j]
			} else {
				block[j] = 0
			}
		}
		// For the final block, the "1" bit must be at 2^(8*rem),
		// not at 2^128. For a circuit you might choose fixed-size
		// messages and avoid this branch altogether.
		// Here we quickly adapt by zeroing the regular 1-bit and
		// setting the correct one.
		// First, clear the implicit 1 we added in loadM:
		// we call loadM, then adjust.
		poly1305BlockPartial(&st, &block, rem)
	}

	return poly1305Finish(&st)
}

// poly1305BlockPartial: like poly1305Block but places the "1" at 8*rem.
func poly1305BlockPartial(st *poly1305State, block *[16]byte, rem int) {
	// Interpret block as integer, but we will add 1<<(8*rem) manually.
	// For circuit use, you'd typically avoid this by fixing message length.
	var m [5]uint64

	// same as loadM, but without the +1<<24
	t0 := uint64(binary.GetUint32LSB(block[0:4]))
	t1 := uint64(binary.GetUint32LSB(block[4:8]))
	t2 := uint64(binary.GetUint32LSB(block[8:12]))
	t3 := uint64(binary.GetUint32LSB(block[12:16]))

	m[0] = t0 & mask26
	m[1] = ((t0 >> 26) | (t1 << 6)) & mask26
	m[2] = ((t1 >> 20) | (t2 << 12)) & mask26
	m[3] = ((t2 >> 14) | (t3 << 18)) & mask26
	m[4] = (t3 >> 8) & 0x3fffff

	// Add 1 at 8*rem.
	// Position of that bit in limb representation is a little fiddly.
	// For MPC, you'd typically avoid variable rem, but this keeps correctness.
	bitPos := uint(rem * 8)
	limb := bitPos / uint32(26)
	off := bitPos % uint32(26)
	if limb < 5 {
		m[limb] += 1 << off
	}

	// then same as poly1305Block
	h0 := st.h[0] + m[0]
	h1 := st.h[1] + m[1]
	h2 := st.h[2] + m[2]
	h3 := st.h[3] + m[3]
	h4 := st.h[4] + m[4]

	r0 := st.r[0]
	r1 := st.r[1]
	r2 := st.r[2]
	r3 := st.r[3]
	r4 := st.r[4]

	s1 := st.r5[1]
	s2 := st.r5[2]
	s3 := st.r5[3]
	s4 := st.r5[4]

	d0 := h0*r0 + h1*s4 + h2*s3 + h3*s2 + h4*s1
	d1 := h0*r1 + h1*r0 + h2*s4 + h3*s3 + h4*s2
	d2 := h0*r2 + h1*r1 + h2*r0 + h3*s4 + h4*s3
	d3 := h0*r3 + h1*r2 + h2*r1 + h3*r0 + h4*s4
	d4 := h0*r4 + h1*r3 + h2*r2 + h3*r1 + h4*r0

	c := d0 >> 26
	h0 = d0 & mask26
	d1 += c
	c = d1 >> 26
	h1 = d1 & mask26
	d2 += c
	c = d2 >> 26
	h2 = d2 & mask26
	d3 += c
	c = d3 >> 26
	h3 = d3 & mask26
	d4 += c
	c = d4 >> 26
	h4 = d4 & mask26

	h0 += c * 5
	c = h0 >> 26
	h0 &= mask26
	h1 += c

	st.h[0] = h0
	st.h[1] = h1
	st.h[2] = h2
	st.h[3] = h3
	st.h[4] = h4
}

func Encrypt(key [KeySize]byte, nonce [NonceSize]byte,
	plaintext, aad []byte) []byte {

	var n [12]byte
	copy(n[:], nonce)

	// Poly1305 key from block 0
	block0 := chacha20Block(key, 0, n)
	polyKey := block0[:32]

	// Encrypt with counter=1
	ciphertext := chacha20XOR(key, n, 1, plaintext)

	// Build MAC input
	macInput := buildPoly1305Msg(aad, ciphertext)
	tag := poly1305TagBytes(macInput, polyKey)

	result := make([]byte, len(ciphertext)+len(tag))
	l := copy(result, ciphertext)
	copy(result[l:], tag)

	return result
}

func Decrypt(key [KeySize]byte, nonce [NonceSize]byte, ciphertext, aad []byte) (
	[]byte, bool) {

	var n [12]byte
	copy(n[:], nonce)

	block0 := chacha20Block(key, 0, n)
	polyKey := block0[:32]

	l := len(ciphertext) - TagSize

	cipher := ciphertext[:l]
	tag := ciphertext[l:]

	macInput := buildPoly1305Msg(aad, cipher)
	expected := poly1305TagBytes(macInput, polyKey)

	plaintext := chacha20XOR(key, n, 1, ciphertext)

	return plaintext, bytes.Equal(expected[:], tag[:])
}
