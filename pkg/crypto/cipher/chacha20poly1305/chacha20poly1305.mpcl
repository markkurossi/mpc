// -*- go -*-
//
// Copyright (c) 2025 Markku Rossi
//
// All rights reserved.
//

// Package chacha20poly1305 implements the ChaCha20-Poly1305 AEAD, as
// specified in RFC 8439.
package chacha20poly1305

import (
	"bytes"
	"crypto/chacha20"
	"crypto/poly1305"
	"encoding/binary"
)

func Seal(key [chacha20.KeySize]byte, nonce [chacha20.NonceSize]byte,
	plaintext, aad []byte) []byte {

	var n [chacha20.NonceSize]byte
	copy(n[:], nonce)

	// Poly1305 key from block 0
	block0 := chacha20.Block(key, 0, n)
	polyKey := block0[:32]

	// Encrypt with counter=1
	ciphertext := chacha20.XORKeyStream(key, n, 1, plaintext)

	tag := tagBytes(aad, ciphertext, polyKey)

	result := make([]byte, len(ciphertext)+len(tag))
	l := copy(result, ciphertext)
	copy(result[l:], tag)

	return result
}

func Open(key [chacha20.KeySize]byte, nonce [chacha20.NonceSize]byte,
	ciphertext, aad []byte) ([]byte, bool) {

	var n [chacha20.NonceSize]byte
	copy(n[:], nonce)

	block0 := chacha20.Block(key, 0, n)
	polyKey := block0[:32]

	l := len(ciphertext) - poly1305.TagSize

	cipher := ciphertext[:l]
	tag := ciphertext[l:]

	expected := tagBytes(aad, cipher, polyKey)

	plaintext := chacha20.XORKeyStream(key, n, 1, ciphertext)

	return plaintext, bytes.Equal(expected[:], tag[:])
}

func tagBytes(aad []byte, ct []byte, key [32]byte) [16]byte {

	aadPad := paddingN(len(aad), 16)
	ctPad := paddingN(len(ct), 16)

	input := make([]byte, len(aad)+aadPad+len(ct)+ctPad+16)
	copy(input, aad)
	copy(input[len(aad)+aadPad:], ct)
	input = binary.PutUint64LSB(input, len(input)-16, uint64(len(aad)))
	input = binary.PutUint64LSB(input, len(input)-8, uint64(len(ct)))

	st := poly1305.Init(key)

	poly1305.Update(&st, input)

	return poly1305.Finalize(&st)
}
