// -*- go -*-
//
// Copyright (c) 2025 Markku Rossi
//
// All rights reserved.
//

// Package chacha20poly1305 implements the ChaCha20-Poly1305 AEAD, as
// specified in RFC 8439.
package chacha20poly1305

import (
	"bytes"
	"crypto/chacha20"
	"crypto/poly1305"
	"encoding/binary"
)

const (
	// NonceSize specifies the nonce size in bytes.
	NonceSize = chacha20.NonceSize

	// TagSize specifies the tag size in bytes.
	TagSize = poly1305.TagSize
)

// Seal encrypts the plaintext in ChaCha20Poly1305 mode. The key
// specifies the ChaCha20 encryption key and nonce is an unique
// initialization vector; the nonce must not be reused for the same
// encryption key. The additionalData specifies additional data that
// is authenticated but not encrypted. The input plaintext can be of
// any length i.e. it don't have to be padded to cipher block size.
func Seal(key [chacha20.KeySize]byte, nonce [NonceSize]byte,
	plaintext, aad []byte) []byte {

	var n [NonceSize]byte
	copy(n[:], nonce)

	// Poly1305 key from block 0
	block0 := chacha20.Block(key, 0, n)
	polyKey := block0[:32]

	// Encrypt with counter=1
	ciphertext := chacha20.XORKeyStream(key, n, 1, plaintext)

	tag := tagBytes(aad, ciphertext, polyKey)

	result := make([]byte, len(ciphertext)+len(tag))
	l := copy(result, ciphertext)
	copy(result[l:], tag)

	return result
}

// Open decrypts the ciphertext in ChaCha20Poly1305 mode. They key
// specifies the ChaCha20 encryption key and nonce is an unique
// initialization vector; the nonce must not be reused for the same
// encryption key. The additionalData specifies additional data that
// is was authenticated but not encrypted when the ciphertext was
// created.
func Open(key [chacha20.KeySize]byte, nonce [NonceSize]byte,
	ciphertext, aad []byte) ([]byte, bool) {

	var n [NonceSize]byte
	copy(n[:], nonce)

	block0 := chacha20.Block(key, 0, n)
	polyKey := block0[:32]

	l := len(ciphertext) - TagSize

	cipher := ciphertext[:l]
	tag := ciphertext[l:]

	expected := tagBytes(aad, cipher, polyKey)

	plaintext := chacha20.XORKeyStream(key, n, 1, cipher)

	return plaintext, bytes.Equal(expected[:], tag[:])
}

func tagBytes(aad []byte, ct []byte, key [32]byte) [16]byte {

	aadPad := paddingN(len(aad), 16)
	ctPad := paddingN(len(ct), 16)

	input := make([]byte, len(aad)+aadPad+len(ct)+ctPad+16)
	copy(input, aad)
	copy(input[len(aad)+aadPad:], ct)
	input = binary.PutUint64LSB(input, len(input)-16, uint64(len(aad)))
	input = binary.PutUint64LSB(input, len(input)-8, uint64(len(ct)))

	st := poly1305.Init(key)

	poly1305.Update(&st, input)

	return poly1305.Finalize(&st)
}
