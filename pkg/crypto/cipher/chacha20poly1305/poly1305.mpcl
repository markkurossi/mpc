// -*- go -*-
//
// Copyright (c) 2021-2025 Markku Rossi
//
// All rights reserved.
//

package chacha20poly1305

//
// ===================== Poly1305 core (5×26-bit) =====================
//
// Internal representation:
// h, r are each 5 limbs, each limb < 2^26.
// Operations are mod 2^130 - 5.
// This maps very cleanly to boolean circuits: add, mul, shifts.
//

type poly1305State struct {
	r   [5]uint64
	r5  [5]uint64 // r * 5 (precomputed)
	h   [5]uint64
	pad [4]uint32 // s (the second half of one-time key)
}

const mask26 = (1 << 26) - 1

// clampR clamps the first 16 bytes of r as in RFC 8439.
func clampR(rBytes *[16]byte) {
	rBytes[3] &= 15
	rBytes[4] &= 252
	rBytes[7] &= 15
	rBytes[8] &= 252
	rBytes[11] &= 15
	rBytes[12] &= 252
}

// loadR loads clamped rBytes (16 bytes) into 5×26-bit limbs.
func loadR(rBytes *[16]byte, out *[5]uint64) {
	// Interpret as 4 little-endian 32-bit words
	t0 := uint64(binary.GetUint32LSB(rBytes[0:4]))
	t1 := uint64(binary.GetUint32LSB(rBytes[4:8]))
	t2 := uint64(binary.GetUint32LSB(rBytes[8:12]))
	t3 := uint64(binary.GetUint32LSB(rBytes[12:16]))

	out[0] = t0 & mask26
	out[1] = ((t0 >> 26) | (t1 << 6)) & mask26
	out[2] = ((t1 >> 20) | (t2 << 12)) & mask26
	out[3] = ((t2 >> 14) | (t3 << 18)) & mask26
	out[4] = (t3 >> 8) & 0x3fffff // only 22 bits used
}

func poly1305Init(st *poly1305State, key [32]byte) {
	var rBytes [16]byte
	copy(rBytes[:], key[0:16])

	clampR(&rBytes)
	loadR(&rBytes, &st.r)

	for i := 0; i < 5; i++ {
		st.r5[i] = st.r[i] * 5
	}

	st.h[0] = 0
	st.h[1] = 0
	st.h[2] = 0
	st.h[3] = 0
	st.h[4] = 0

	st.pad[0] = binary.GetUint32LSB(key[16:20])
	st.pad[1] = binary.GetUint32LSB(key[20:24])
	st.pad[2] = binary.GetUint32LSB(key[24:28])
	st.pad[3] = binary.GetUint32LSB(key[28:32])
}

// loadM loads a 16-byte block into 5×26-bit limbs and adds the extra 1 bit
// (the "1" appended above the block).
func loadM(block *[16]byte, out *[5]uint64) {
	t0 := uint64(binary.GetUint32LSB(block[0:4]))
	t1 := uint64(binary.GetUint32LSB(block[4:8]))
	t2 := uint64(binary.GetUint32LSB(block[8:12]))
	t3 := uint64(binary.GetUint32LSB(block[12:16]))

	out[0] = t0 & mask26
	out[1] = ((t0 >> 26) | (t1 << 6)) & mask26
	out[2] = ((t1 >> 20) | (t2 << 12)) & mask26
	out[3] = ((t2 >> 14) | (t3 << 18)) & mask26
	out[4] = (t3 >> 8) & 0x3fffff

	// add the "1" bit (2^128) = 1<<24 in limb 4 (since 4*26 = 104, 128-104 = 24)
	out[4] += 1 << 24
}

// poly1305Block: process a single 16-byte block.
func poly1305Block(st *poly1305State, block *[16]byte) {
	var m [5]uint64
	loadM(block, &m)

	h0 := st.h[0] + m[0]
	h1 := st.h[1] + m[1]
	h2 := st.h[2] + m[2]
	h3 := st.h[3] + m[3]
	h4 := st.h[4] + m[4]

	r0 := st.r[0]
	r1 := st.r[1]
	r2 := st.r[2]
	r3 := st.r[3]
	r4 := st.r[4]

	s1 := st.r5[1]
	s2 := st.r5[2]
	s3 := st.r5[3]
	s4 := st.r5[4]

	d0 := h0*r0 + h1*s4 + h2*s3 + h3*s2 + h4*s1
	d1 := h0*r1 + h1*r0 + h2*s4 + h3*s3 + h4*s2
	d2 := h0*r2 + h1*r1 + h2*r0 + h3*s4 + h4*s3
	d3 := h0*r3 + h1*r2 + h2*r1 + h3*r0 + h4*s4
	d4 := h0*r4 + h1*r3 + h2*r2 + h3*r1 + h4*r0

	// carry propagation
	c := d0 >> 26
	h0 = d0 & mask26
	d1 += c
	c = d1 >> 26
	h1 = d1 & mask26
	d2 += c
	c = d2 >> 26
	h2 = d2 & mask26
	d3 += c
	c = d3 >> 26
	h3 = d3 & mask26
	d4 += c
	c = d4 >> 26
	h4 = d4 & mask26

	// final reduction step: fold carry from h4 into h0..h1
	h0 += c * 5
	c = h0 >> 26
	h0 &= mask26
	h1 += c

	st.h[0] = h0
	st.h[1] = h1
	st.h[2] = h2
	st.h[3] = h3
	st.h[4] = h4
}

// poly1305Finish finalizes and produces 16-byte tag.
func poly1305Finish(st *poly1305State) [16]byte {
	h0 := st.h[0]
	h1 := st.h[1]
	h2 := st.h[2]
	h3 := st.h[3]
	h4 := st.h[4]

	// fully carry
	c := h1 >> 26
	h1 &= mask26
	h2 += c
	c = h2 >> 26
	h2 &= mask26
	h3 += c
	c = h3 >> 26
	h3 &= mask26
	h4 += c
	c = h4 >> 26
	h4 &= mask26
	h0 += c * 5
	c = h0 >> 26
	h0 &= mask26
	h1 += c

	// Compute h + -p, then conditional select
	// p = 2^130 - 5
	g0 := h0 + 5
	c = g0 >> 26
	g0 &= mask26
	g1 := h1 + c
	c = g1 >> 26
	g1 &= mask26
	g2 := h2 + c
	c = g2 >> 26
	g2 &= mask26
	g3 := h3 + c
	c = g3 >> 26
	g3 &= mask26
	g4 := h4 + c - (1 << 26)

	// mask = 0xffffffff if g4 has no borrow, else 0x00000000
	mask := (g4 >> 63) - 1

	// select h or g based on mask
	ff := uint64(0xffffffffffffffff)
	h0 = (h0 & (ff ^ mask)) | (g0 & mask)
	h1 = (h1 & (ff ^ mask)) | (g1 & mask)
	h2 = (h2 & (ff ^ mask)) | (g2 & mask)
	h3 = (h3 & (ff ^ mask)) | (g3 & mask)
	h4 = (h4 & (ff ^ mask)) | ((g4 + (1 << 26)) & mask26 & mask) // restore if selected

	// collapse to 128 bits
	f0 := h0 + (h1 << 26)
	f1 := (h1 >> 6) + (h2 << 20)
	f2 := (h2 >> 12) + (h3 << 14)
	f3 := (h3 >> 18) + (h4 << 8)

	// add pad
	f0 += uint64(st.pad[0])
	c0 := f0 >> 32
	f0 &= 0xffffffff

	f1 += uint64(st.pad[1]) + c0
	c1 := f1 >> 32
	f1 &= 0xffffffff

	f2 += uint64(st.pad[2]) + c1
	c2 := f2 >> 32
	f2 &= 0xffffffff

	f3 += uint64(st.pad[3]) + c2
	f3 &= 0xffffffff

	var tag [16]byte
	tag = binary.PutUint32LSB(tag, 0, uint32(f0))
	tag = binary.PutUint32LSB(tag, 4, uint32(f1))
	tag = binary.PutUint32LSB(tag, 8, uint32(f2))
	tag = binary.PutUint32LSB(tag, 12, uint32(f3))

	return tag
}
