// -*- go -*-

package chacha20poly1305

import (
	"encoding/binary"
)

// Poly1305State holds numbers in saturated 64-bit little-endian
// limbs. That is, the value of [x0, x1, x2] is x[0] + x[1] * 2⁶⁴ +
// x[2] * 2¹²⁸.
type Poly1305State struct {
	// h is the main accumulator. It is to be interpreted modulo 2¹³⁰ - 5, but
	// can grow larger during and after rounds.
	h [3]uint64
	// r and s are the private key components.
	r [2]uint64
	s [2]uint64
}

// [rMask0, rMask1] is the specified Poly1305 clamping mask in little-endian. It
// clears some bits of the secret coefficient to make it possible to implement
// multiplication more efficiently.
const (
	rMask0 = uint64(0x0FFFFFFC0FFFFFFF)
	rMask1 = uint64(0x0FFFFFFC0FFFFFFC)
)

func poly1305Init(key [32]byte) Poly1305State {
	var st Poly1305State

	st.r[0] = binary.GetUint64LSB(key[0:8]) & rMask0
	st.r[1] = binary.GetUint64LSB(key[8:16]) & rMask1
	st.s[0] = binary.GetUint64LSB(key[16:24])
	st.s[1] = binary.GetUint64LSB(key[24:32])

	return st
}

const (
	BlockSize = 64
)

func update(state *Poly1305State, msg []byte) {

	h0 := state.h[0]
	h1 := state.h[1]
	h2 := state.h[2]
	r0 := state.r[0]
	r1 := state.r[1]

	h := uint192(h0) | (uint192(h1) << 64) | (uint192(h2) << 128)
	r := uint192(r0) | (uint192(r1) << 64)

	var m, cc uint192
	var t uint384

	for ofs := 0; ofs < len(msg); ofs += TagSize {
		m = uint192(binary.GetUintLSB(msg[ofs : ofs+TagSize]))
		m |= uint192(1) << 128

		h = h + m

		t = wideMul(h, r)

		h = uint192(t & 0x3ffffffffffffffffffffffffffffffff)
		cc = uint192(t >> 130)

		// Add cc*5
		h += cc
		h += (cc << 2)

	}
	state.h[0] = uint64(h)
	state.h[1] = uint64(h >> 64)
	state.h[2] = uint64(h >> 128)
}

const (
	p = uint192(0x3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFB)
)

func finalize(state *Poly1305State) [TagSize]byte {
	var result [TagSize]byte

	// After the partial reduction in update, h might be more than
	// 2¹³⁰ - 5, but will be less than 2 * (2¹³⁰ - 5). To complete the
	// reduction in constant time, we compute t = h - (2¹³⁰ - 5), and
	// select h as the result if the subtraction underflows, and t
	// otherwise.
	h := uint192(state.h[0]) | (uint192(state.h[1]) << 64) |
		(uint192(state.h[2]) << 128)

	sub := h - p
	if (sub & uint192(1<<192)) != 0 {
		h = sub
	}

	h &= uint192(0xffffffffffffffffffffffffffffffff)

	s := uint192(state.s[0]) | (uint192(state.s[1]) << 64)
	h += s

	result = binary.PutUint64LSB(result, 0, uint64(h))
	result = binary.PutUint64LSB(result, 8, uint64(h>>64))

	return result
}

func poly1305TagBytes(aad []byte, ct []byte, key [32]byte) (
	uint, uint64, uint64, uint64, uint64, [16]byte) {

	st := poly1305Init(key)

	input := make([]byte, len(aad)+5+len(ct)+6+16)
	copy(input, aad)
	copy(input[16:], ct)
	input = binary.PutUint64LSB(input, 48, uint64(len(aad)))
	input = binary.PutUint64LSB(input, 56, uint64(len(ct)))

	update(&st, input)

	var h0, h1, h2 uint64
	tag := finalize(&st)
	return uint32(0), h0, h1, h2, uint32(0), tag
}
