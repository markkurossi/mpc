// -*- go -*-
//
// Copyright (c) 2025 Markku Rossi
//
// All rights reserved.
//

package p256

// -----------------------------------------------------------------------------
// Field arithmetic helpers (NO raw + / - on field elements)
// -----------------------------------------------------------------------------

func addMod(a, b uint256) uint256 {
	s := a + b
	if s < a {
		s -= P
	}
	if s >= P {
		s -= P
	}
	return s
}

func subMod(a, b uint256) uint256 {
	if a >= b {
		return a - b
	}
	return a + P - b
}

func mulMod(a, b uint256) uint256 {
	r := wideMul(a, b)
	return uint256(r % uint512(P))
}

func sqrMod(a uint256) uint256 {
	r := wideMul(a, a)
	return uint256(r % uint512(P))
}

// AddSafe performs elliptic curve point addition on P256 Adds two points
// (x1, y1) and (x2, y2) and returns (x3, y3) Handles special cases:
// point at infinity, point doubling
func AddSafe(x1, y1, x2, y2 uint256) (x3, y3 uint256) {
	if x1 == 0 && y1 == 0 {
		return x2, y2
	}
	if x2 == 0 && y2 == 0 {
		return x1, y1
	}

	if x1 == x2 {
		if addMod(y1, y2) == 0 {
			return 0, 0
		}
		return curveDouble(x1, y1)
	}
	return Add(x1, y1, x2, y2)
}

// Add performs elliptic curve point addition on P256 Adds two points
// (x1, y1) and (x2, y2) and returns (x3, y3).
func Add(x1, y1, x2, y2 uint256) (x3, y3 uint256) {
	dy := subMod(y2, y1)
	dx := subMod(x2, x1)

	l := mulMod(dy, modInverse(dx))

	x3 = subMod(subMod(sqrMod(l), x1), x2)
	y3 = subMod(mulMod(l, subMod(x1, x3)), y1)
	return
}

// -----------------------------------------------------------------------------
// Point doubling (affine wrapper)
// -----------------------------------------------------------------------------

func curveDouble(x, y uint256) (x3, y3 uint256) {
	if x == 0 && y == 0 {
		return 0, 0
	}
	return curveDoubleProjective(x, y)
}

// -----------------------------------------------------------------------------
// Jacobian doubling (affine in → affine out)
// -----------------------------------------------------------------------------

func curveDoubleProjective(x, y uint256) (x3, y3 uint256) {
	X1, Y1, Z1 := x, y, uint256(1)

	Y1sq := sqrMod(Y1)
	S := mulMod(mulMod(uint256(4), X1), Y1sq)

	X1sq := sqrMod(X1)
	Z1sq := sqrMod(Z1)
	Z1four := sqrMod(Z1sq)

	M := mulMod(uint256(3), subMod(X1sq, Z1four))

	X3 := subMod(sqrMod(M), mulMod(uint256(2), S))

	Y1four := sqrMod(Y1sq)
	Y3 := subMod(
		mulMod(M, subMod(S, X3)),
		mulMod(uint256(8), Y1four))

	Z3 := mulMod(uint256(2), mulMod(Y1, Z1))

	return projectiveToAffine(X3, Y3, Z3)
}

// -----------------------------------------------------------------------------
// Projective → affine
// -----------------------------------------------------------------------------

func projectiveToAffine(X, Y, Z uint256) (x, y uint256) {
	if Z == 0 {
		return 0, 0
	}

	Zinv := modInverse(Z)
	Zinv2 := sqrMod(Zinv)
	Zinv3 := mulMod(Zinv2, Zinv)

	x = mulMod(X, Zinv2)
	y = mulMod(Y, Zinv3)
	return
}

// -----------------------------------------------------------------------------
// Scalar multiplication (double-and-add, projective internal)
// -----------------------------------------------------------------------------

func curveScalarMult(k uint256, x, y uint256) (x3, y3 uint256) {
	resX, resY, resZ := uint256(0), uint256(0), uint256(0)
	tmpX, tmpY, tmpZ := x, y, uint256(1)

	for i := 0; i < 256; i++ {
		if ((k >> i) & 1) == 1 {
			resX, resY, resZ =
				curveAddProjectiveInternal(resX, resY, resZ, tmpX, tmpY, tmpZ)
		}
		tmpX, tmpY, tmpZ =
			curveDoubleProjectiveInternal(tmpX, tmpY, tmpZ)
	}

	return projectiveToAffine(resX, resY, resZ)
}

// -----------------------------------------------------------------------------
// Jacobian–Jacobian addition (internal)
// -----------------------------------------------------------------------------

func curveAddProjectiveInternal(
	X1, Y1, Z1 uint256,
	X2, Y2, Z2 uint256) (X3, Y3, Z3 uint256) {

	if Z1 == 0 {
		return X2, Y2, Z2
	}
	if Z2 == 0 {
		return X1, Y1, Z1
	}

	Z1sq := sqrMod(Z1)
	Z2sq := sqrMod(Z2)

	U1 := mulMod(X1, Z2sq)
	U2 := mulMod(X2, Z1sq)

	Z1cu := mulMod(Z1sq, Z1)
	Z2cu := mulMod(Z2sq, Z2)

	S1 := mulMod(Y1, Z2cu)
	S2 := mulMod(Y2, Z1cu)

	if U1 == U2 {
		if S1 == S2 {
			return curveDoubleProjectiveInternal(X1, Y1, Z1)
		}
		return 0, 0, 0
	}

	H := subMod(U2, U1)
	R := subMod(S2, S1)

	Hsq := sqrMod(H)
	Hcu := mulMod(Hsq, H)

	Rsq := sqrMod(R)
	U1H2 := mulMod(U1, Hsq)

	X3 = subMod(subMod(Rsq, Hcu), mulMod(uint256(2), U1H2))
	Y3 = subMod(
		mulMod(R, subMod(U1H2, X3)),
		mulMod(S1, Hcu))
	Z3 = mulMod(H, mulMod(Z1, Z2))
	return
}

// -----------------------------------------------------------------------------
// Jacobian doubling (internal)
// -----------------------------------------------------------------------------

func curveDoubleProjectiveInternal(
	X1, Y1, Z1 uint256) (X3, Y3, Z3 uint256) {

	if Z1 == 0 {
		return 0, 0, 0
	}

	Y1sq := sqrMod(Y1)
	S := mulMod(mulMod(uint256(4), X1), Y1sq)

	X1sq := sqrMod(X1)
	Z1sq := sqrMod(Z1)
	Z1four := sqrMod(Z1sq)

	M := mulMod(uint256(3), subMod(X1sq, Z1four))

	X3 = subMod(sqrMod(M), mulMod(uint256(2), S))

	Y1four := sqrMod(Y1sq)
	Y3 = subMod(
		mulMod(M, subMod(S, X3)),
		mulMod(uint256(8), Y1four))

	Z3 = mulMod(uint256(2), mulMod(Y1, Z1))
	return
}

// -----------------------------------------------------------------------------
// Modular inverse and exponentiation
// -----------------------------------------------------------------------------

func modInverse(a uint256) uint256 {
	if a == 0 {
		return 0
	}
	return modExp(a, P-uint256(2))
}

func modExp(base, exp uint256) uint256 {
	result := uint256(1)
	b := base

	for i := 0; i < 256; i++ {
		if ((exp >> i) & uint256(1)) == 1 {
			result = mulMod(result, b)
		}
		b = sqrMod(b)
	}
	return result
}
