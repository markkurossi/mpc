//
// Copyright (c) 2019-2022 Markku Rossi
//
// All rights reserved.
//

package ast

import (
	"fmt"

	"github.com/markkurossi/mpc/compiler/ssa"
	"github.com/markkurossi/mpc/compiler/utils"
	"github.com/markkurossi/mpc/types"
)

const (
	debugConstFold = false
)

// SSA implements the compiler.ast.AST.SSA for list statements.
func (ast List) SSA(block *ssa.Block, ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {

	var err error

	for _, b := range ast {
		if block.Dead {
			warn := true
			ret, ok := b.(*Return)
			if ok && ret.AutoGenerated {
				warn = false
			}
			if warn {
				ctx.logger.Warningf(b.Location(), "unreachable code")
			}
			break
		}
		block, _, err = b.SSA(block, ctx, gen)
		if err != nil {
			return nil, nil, err
		}
	}

	return block, nil, nil
}

// SSA implements the compiler.ast.AST.SSA for function definitions.
func (ast *Func) SSA(block *ssa.Block, ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {

	ctx.Start().Name = fmt.Sprintf("%s#%d", ast.Name, ast.NumInstances)
	ctx.Return().Name = fmt.Sprintf("%s.ret#%d", ast.Name, ast.NumInstances)
	ast.NumInstances++

	// Define return variables.
	for idx, ret := range ast.Return {
		if len(ret.Name) == 0 {
			ret.Name = fmt.Sprintf("%%ret%d", idx)
		}
		typeInfo, err := ret.Type.Resolve(NewEnv(block), ctx, gen)
		if err != nil {
			return nil, nil, ctx.Errorf(ret, "invalid return type: %s", err)
		}
		r := gen.NewVal(ret.Name, typeInfo, ctx.Scope())
		block.Bindings.Set(r, nil)
	}

	ast.Body = append(ast.Body, &Return{
		Point:         ast.End,
		AutoGenerated: true,
	})

	block, _, err := ast.Body.SSA(block, ctx, gen)
	if err != nil {
		return nil, nil, err
	}

	// Select return variables.
	var vars []ssa.Value
	for _, ret := range ast.Return {
		v, ok := ctx.Start().ReturnBinding(ssa.NewReturnBindingCTX(), ret.Name,
			ctx.Return(), gen)
		if !ok {
			return nil, nil, ctx.Errorf(ast, "undefined variable '%s'",
				ret.Name)
		}
		vars = append(vars, v)
	}

	caller := ctx.Caller()
	if caller == nil {
		ctx.Return().AddInstr(ssa.NewRetInstr(vars))
	}

	return block, vars, nil
}

// SSA implements the compiler.ast.AST.SSA for constant definitions.
func (ast *ConstantDef) SSA(block *ssa.Block, ctx *Codegen,
	gen *ssa.Generator) (*ssa.Block, []ssa.Value, error) {

	typeInfo, err := ast.Type.Resolve(NewEnv(block), ctx, gen)
	if err != nil {
		return nil, nil, err
	}

	env := NewEnv(block)

	constVal, ok, err := ast.Init.Eval(env, ctx, gen)
	if err != nil {
		return nil, nil, err
	}
	if !ok {
		return nil, nil, ctx.Errorf(ast.Init, "init value is not constant")
	}
	constVar := gen.Constant(constVal, typeInfo)
	if typeInfo.Type == types.TUndefined {
		typeInfo.Type = constVar.Type.Type
	}
	if typeInfo.Bits == 0 {
		typeInfo.Bits = constVar.Type.Bits
	}
	if !typeInfo.CanAssignConst(constVar.Type) {
		return nil, nil, ctx.Errorf(ast.Init,
			"invalid init value %s for type %s", constVar.Type, typeInfo)
	}

	_, ok = block.Bindings.Get(ast.Name)
	if ok {
		return nil, nil, ctx.Errorf(ast, "constant %s already defined",
			ast.Name)
	}
	lValue := constVar
	lValue.Name = ast.Name
	block.Bindings.Set(lValue, &constVar)
	gen.AddConstant(constVal)

	return block, nil, nil
}

// SSA implements the compiler.ast.AST.SSA for variable definitions.
func (ast *VariableDef) SSA(block *ssa.Block, ctx *Codegen,
	gen *ssa.Generator) (*ssa.Block, []ssa.Value, error) {

	typeInfo, err := ast.Type.Resolve(NewEnv(block), ctx, gen)
	if err != nil {
		return nil, nil, ctx.Errorf(ast, "invalid variable type: %s", err)
	}

	for _, n := range ast.Names {
		var init ssa.Value
		if ast.Init == nil {
			if typeInfo.Undefined() {
				return nil, nil, ctx.Errorf(ast, "undefined variable")
			}
			if typeInfo.Bits == 0 {
				return nil, nil, ctx.Errorf(ast, "undefined variable size: %s",
					typeInfo)
			}
			initVal, err := initValue(typeInfo)
			if err != nil {
				return nil, nil, ctx.Errorf(ast, "%s", err)
			}
			init = gen.Constant(initVal, typeInfo)
			gen.AddConstant(init)
		} else {
			// Check if the init value is constant.
			env := NewEnv(block)
			constVal, ok, err := ast.Init.Eval(env, ctx, gen)
			if err != nil {
				return nil, nil, err
			}

			if ok {
				gen.AddConstant(constVal)
				init = constVal
			} else {
				var v []ssa.Value
				block, v, err = ast.Init.SSA(block, ctx, gen)
				if err != nil {
					return nil, nil, err
				}
				if len(v) != 1 {
					return nil, nil, ctx.Errorf(ast,
						"multiple-value %s used in single-value context",
						ast.Init)
				}
				init = v[0]
			}
		}

		if typeInfo.Undefined() {
			typeInfo = init.Type
		} else if !typeInfo.CanAssignConst(init.Type) {
			return nil, nil, ctx.Errorf(ast,
				"cannot use %s (type %s) as type %s in assignment",
				init, init.Type, typeInfo)
		}

		lValue := gen.NewVal(n, typeInfo, ctx.Scope())
		// XXX lValue.Const = init.Const
		block.Bindings.Set(lValue, nil)

		block.AddInstr(ssa.NewMovInstr(init, lValue))
	}
	return block, nil, nil
}

func initValue(typeInfo types.Info) (interface{}, error) {
	switch typeInfo.Type {
	case types.TBool:
		return false, nil
	case types.TInt, types.TUint:
		return int32(0), nil
	case types.TString:
		return "", nil
	case types.TStruct:
		var init []interface{}
		for _, field := range typeInfo.Struct {
			fieldInit, err := initValue(field.Type)
			if err != nil {
				return nil, err
			}
			init = append(init, fieldInit)
		}
		return init, nil
	case types.TArray:
		elInit, err := initValue(*typeInfo.ElementType)
		if err != nil {
			return nil, err
		}
		init := make([]interface{}, typeInfo.ArraySize)
		for i := types.Size(0); i < typeInfo.ArraySize; i++ {
			init[i] = elInit
		}
		return init, nil
	default:
		return nil, fmt.Errorf("unsupported variable type: %s", typeInfo.Type)
	}
}

// SSA implements the compiler.ast.AST.SSA for assignment expressions.
func (ast *Assign) SSA(block *ssa.Block, ctx *Codegen,
	gen *ssa.Generator) (*ssa.Block, []ssa.Value, error) {

	var values []ssa.Value

	for _, expr := range ast.Exprs {
		// Check if init value is constant.
		env := NewEnv(block)
		constVal, ok, err := expr.Eval(env, ctx, gen)
		if err != nil {
			return nil, nil, err
		}
		if ok {
			gen.AddConstant(constVal)
			values = append(values, constVal)
		} else {
			var v []ssa.Value
			block, v, err = expr.SSA(block, ctx, gen)
			if err != nil {
				return nil, nil, err
			}
			if len(v) == 0 {
				return nil, nil, ctx.Errorf(expr, "%s used as value", expr)
			}
			values = append(values, v...)
		}
	}
	if len(ast.LValues) != len(values) {
		return nil, nil, ctx.Errorf(ast,
			"assignment mismatch: %d variables but %d value",
			len(values), len(ast.LValues))
	}

	for idx, lvalue := range ast.LValues {
		rv := values[idx]
		switch lv := lvalue.(type) {
		case *VariableRef:
			// Three options:
			//   1) struct.member
			//   2) package.variable
			//   3) variable

			var dstBindings *ssa.Bindings

			b, ok := block.Bindings.Get(lv.Name.Package)
			if ok {
				dstBindings = block.Bindings
			} else {
				b, ok = ctx.Package.Bindings.Get(lv.Name.Package)
				if ok {
					dstBindings = ctx.Package.Bindings
				}
			}

			if ok {
				var dstName string
				var dstType types.Info
				var dstScope ssa.Scope

				switch b.Type.Type {
				case types.TStruct:
					dstName = b.Name
					dstType = b.Type
					dstScope = b.Scope

				case types.TPtr:
					v := b.Value(block, gen)
					dstName = v.PtrInfo.Name
					dstType = v.PtrInfo.ContainerType
					dstScope = v.PtrInfo.Scope
					dstBindings = v.PtrInfo.Bindings
					b, ok = dstBindings.Get(dstName)
					if !ok {
						return nil, nil, ctx.Errorf(ast, "undefined: %s",
							dstName)
					}
					if b.Type.Type != types.TStruct {
						return nil, nil, ctx.Errorf(ast,
							"%s undefined (%s has no field or method %s)",
							lv.Name, b.Type, lv.Name.Name)
					}

				default:
					return nil, nil, ctx.Errorf(ast,
						"setting elements of non-struct %s", b.Type)
				}

				// Lookup struct field.
				var field *types.StructField
				for _, f := range b.Type.Struct {
					if f.Name == lv.Name.Name {
						field = &f
						break
					}
				}
				if field == nil {
					return nil, nil, ctx.Errorf(ast,
						"%s undefined (%s has no field or method %s)",
						lv.Name, b.Type, lv.Name.Name)
				}

				fromConst := gen.Constant(int32(field.Type.Offset), types.Int32)
				toConst := gen.Constant(int32(field.Type.Offset+
					field.Type.Bits), types.Int32)
				lValue := gen.NewVal(dstName, dstType, dstScope)

				block.AddInstr(ssa.NewAmovInstr(rv, b.Value(block, gen),
					fromConst, toConst, lValue))
				dstBindings.Set(lValue, nil)

				return block, []ssa.Value{lValue}, nil
			}

			// XXX check if rv can be assigned to lv, also do not
			// change the binding's type below in the assignment.

			var lValue ssa.Value
			b, ok = block.Bindings.Get(lv.Name.Name)
			if ast.Define {
				if ok {
					return nil, nil, ctx.Errorf(ast,
						"no new variables on left side of :=")
				}
				lValue = gen.NewVal(lv.Name.Name, rv.Type, ctx.Scope())
				if rv.Type.Type == types.TPtr {
					lValue.PtrInfo = rv.PtrInfo
				}
			} else {
				if !ok {
					return nil, nil, ctx.Errorf(ast, "undefined: %s", lv.Name)
				}
				lValue = gen.NewVal(b.Name, b.Type, ctx.Scope())
			}

			block.AddInstr(ssa.NewMovInstr(rv, lValue))
			block.Bindings.Set(lValue, &rv)

		case *Index:
			if ast.Define {
				return nil, nil, ctx.Errorf(ast,
					"a non-name %s on left side of :=", lv)
			}
			switch arr := lv.Expr.(type) {
			case *VariableRef:
				lrv, _, err := ctx.LookupVar(block, gen, block.Bindings, arr)
				if err != nil {
					return nil, nil, err
				}
				valueType := lrv.ValueType()
				if valueType.Type == types.TPtr {
					valueType = *valueType.ElementType
				}

				if valueType.Type != types.TArray {
					return nil, nil, ctx.Errorf(ast,
						"setting elements of non-array %s (%s)",
						arr, lrv.ValueType())
				}
				arraySize := valueType.ArraySize
				elementSize := valueType.ElementType.Bits

				block, val, err := lv.Index.SSA(block, ctx, gen)
				if err != nil {
					return nil, nil, err
				}
				if len(val) != 1 {
					return nil, nil, ctx.Errorf(lv.Index, "invalid index")
				}
				index, err := val[0].ConstInt()
				if err != nil {
					return nil, nil, ctx.Errorf(lv.Index, "%s", err)
				}

				// Convert index to bit range.
				if index >= arraySize {
					return nil, nil, ctx.Errorf(lv.Index,
						"invalid array index %d (out of bounds for %d-element array)",
						index, arraySize)
				}
				basePtrInfo := lrv.BasePtrInfo()
				from := int32(index*elementSize + basePtrInfo.Offset)
				to := int32(from + int32(elementSize))

				indexType := types.Uint32
				fromConst := gen.Constant(from, indexType)
				toConst := gen.Constant(to, indexType)

				lValue := lrv.LValue()
				block.AddInstr(ssa.NewAmovInstr(rv, lrv.BaseValue(),
					fromConst, toConst, lValue))
				basePtrInfo.Bindings.Set(lValue, nil)

				return block, []ssa.Value{lValue}, nil

			default:
				return nil, nil, ctx.Errorf(ast,
					"array expression not supported: %T", arr)
			}

		case *Unary:
			if ast.Define {
				return nil, nil, ctx.Errorf(ast,
					"a non-name %s on left side of :=", lv)
			}
			if lv.Type != UnaryPtr {
				return nil, nil, ctx.Errorf(ast, "cannot assign to %s", lv)
			}
			switch ptr := lv.Expr.(type) {
			case *VariableRef:
				b, ok := block.Bindings.Get(ptr.Name.Name)
				if !ok {
					return nil, nil, ctx.Errorf(ast, "undefined: %s", ptr.Name)
				}

				if b.Type.Type != types.TPtr {
					return nil, nil, ctx.Errorf(ast,
						"cannot assign non-pointer: %s", ptr.Name)
				}
				v := b.Value(block, gen)
				dstName := v.PtrInfo.Name
				dstType := v.PtrInfo.ContainerType
				dstScope := v.PtrInfo.Scope
				dstBindings := v.PtrInfo.Bindings
				b, ok = dstBindings.Get(dstName)
				if !ok {
					return nil, nil, ctx.Errorf(ast, "undefined: %s", ptr.Name)
				}

				lValue := gen.NewVal(dstName, dstType, dstScope)
				if v.Type.CanAssignConst(rv.Type) {
					// Pointer to value type.
					block.AddInstr(ssa.NewMovInstr(rv, lValue))
				} else if v.Type.ElementType.CanAssignConst(rv.Type) {
					// Pointer to element of value type.
					from := int32(v.PtrInfo.Offset)
					to := from + int32(v.Type.ElementType.Bits)
					fromConst := gen.Constant(from, types.Int32)
					toConst := gen.Constant(to, types.Int32)

					bv := b.Value(block, gen)

					block.AddInstr(ssa.NewAmovInstr(rv,
						bv, fromConst, toConst, lValue))
				} else {
					return nil, nil, ctx.Errorf(ast,
						"can't assign %s with value of type %s",
						lValue.Type.ElementType, rv.Type)
				}
				dstBindings.Set(lValue, nil)

			default:
				return nil, nil, ctx.Errorf(ast,
					"assignment to pointer to %T not supported", ptr)
			}

		default:
			return nil, nil, ctx.Errorf(ast, "cannot assign to %s (%T)", lv, lv)
		}
	}

	return block, values, nil
}

// SSA implements the compiler.ast.AST.SSA for if statements.
func (ast *If) SSA(block *ssa.Block, ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {

	env := NewEnv(block)
	constVal, ok, err := ast.Expr.Eval(env, ctx, gen)
	if err != nil {
		return nil, nil, err
	}
	if ok {
		block.Bindings = env.Bindings
		val, ok := constVal.ConstValue.(bool)
		if !ok {
			return nil, nil, ctx.Errorf(ast.Expr,
				"condition is not boolean expression")
		}
		if val {
			return ast.True.SSA(block, ctx, gen)
		} else if ast.False != nil {
			return ast.False.SSA(block, ctx, gen)
		}
		return block, nil, nil
	}

	block, e, err := ast.Expr.SSA(block, ctx, gen)
	if err != nil {
		return nil, nil, err
	}
	if len(e) == 0 {
		return nil, nil, ctx.Errorf(ast.Expr, "%s used as value", ast.Expr)
	} else if len(e) > 1 {
		return nil, nil, ctx.Errorf(ast.Expr,
			"multiple-value %s used in single-value context", ast.Expr)
	}
	if e[0].Type.Type != types.TBool {
		return nil, nil, ctx.Errorf(ast.Expr,
			"non-bool %s (type %s) used as if condition", ast.Expr, e[0].Type)
	}

	block.BranchCond = e[0]

	// Branch.
	tBlock := gen.BranchBlock(block)

	// True branch.
	tNext, _, err := ast.True.SSA(tBlock, ctx, gen)
	if err != nil {
		return nil, nil, err
	}

	// False (else) branch.
	if ast.False == nil {
		// No else branch.
		if tNext.Dead {
			// True branch terminated.
			tNext = gen.NextBlock(block)
		} else {
			tNext.Bindings = tNext.Bindings.Merge(e[0], block.Bindings)
			block.SetNext(tNext)
		}

		return tNext, nil, nil
	}

	fBlock := gen.NextBlock(block)

	fNext, _, err := ast.False.SSA(fBlock, ctx, gen)
	if err != nil {
		return nil, nil, err
	}

	if fNext.Dead && tNext.Dead {
		// Both branches terminate.
		next := gen.Block()
		next.Dead = true
		return next, nil, nil
	} else if fNext.Dead {
		// False-branch terminates.
		return tNext, nil, nil
	} else if tNext.Dead {
		// True-branch terminates.
		return fNext, nil, nil
	}

	// Both branches continue.

	next := gen.Block()
	tNext.SetNext(next)

	fNext.SetNext(next)

	next.Bindings = tNext.Bindings.Merge(e[0], fNext.Bindings)

	return next, nil, nil
}

// SSA implements the compiler.ast.AST.SSA for call expressions.
func (ast *Call) SSA(block *ssa.Block, ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {

	// Generate call values.

	var callValues [][]ssa.Value
	var v []ssa.Value
	var err error

	env := NewEnv(block)

	for _, expr := range ast.Exprs {
		constVal, ok, err := expr.Eval(env, ctx, gen)
		if err != nil {
			return nil, nil, err
		}
		if ok {
			gen.AddConstant(constVal)
			v = []ssa.Value{constVal}
		} else {
			block, v, err = expr.SSA(block, ctx, gen)
			if err != nil {
				return nil, nil, err
			}
		}
		callValues = append(callValues, v)
	}

	// Resolve called.
	called, err := ctx.LookupFunc(block, ast.Ref)
	if err != nil {
		return nil, nil, err
	}
	if called == nil {
		// Check builtin functions.
		for _, bi := range builtins {
			if bi.Name != ast.Ref.Name.Name {
				continue
			}
			if bi.Type != BuiltinFunc || bi.SSA == nil {
				return nil, nil, ctx.Errorf(ast, "builtin %s used as function",
					bi.Name)
			}
			// Flatten arguments.
			var args []ssa.Value
			for _, arg := range callValues {
				args = append(args, arg...)
			}
			return bi.SSA(block, ctx, gen, args, ast.Location())
		}

		// Resolve name as type.
		typeName := &TypeInfo{
			Type: TypeName,
			Name: ast.Ref.Name,
		}
		typeInfo, err := typeName.Resolve(NewEnv(block), ctx, gen)
		if err != nil {
			return nil, nil, ctx.Errorf(ast, "undefined: %s", ast.Ref)
		}
		if len(callValues) != 1 {
			return nil, nil, ctx.Errorf(ast, "undefined: %s", ast.Ref)
		}
		if len(callValues[0]) == 0 {
			return nil, nil, ctx.Errorf(ast.Exprs[0],
				"%s used as value", ast.Exprs[0])
		}
		if len(callValues[0]) > 1 {
			return nil, nil, ctx.Errorf(ast.Exprs[0],
				"multiple-value %s in single-value context", ast.Exprs[0])
		}

		// Convert value to type

		cv := callValues[0][0]
		t := gen.AnonVal(typeInfo)

		if cv.Type.Type == types.TInt && typeInfo.Type == types.TInt &&
			typeInfo.Bits > cv.Type.Bits {
			// The src and dst are signed integers and we are casting
			// to bigger bit size. Use sign-extension version smov.
			block.AddInstr(ssa.NewSmovInstr(cv, t))
		} else {
			block.AddInstr(ssa.NewMovInstr(cv, t))
		}

		return block, []ssa.Value{t}, nil
	}

	var args []ssa.Value

	if len(callValues) == 0 {
		if len(called.Args) != 0 {
			return nil, nil, ast.error(ctx, "not enough arguments",
				callValues, called.Args)
		}
	} else if len(callValues) == 1 {
		if len(callValues[0]) < len(called.Args) {
			return nil, nil, ast.error(ctx, "not enough arguments",
				callValues, called.Args)
		} else if len(callValues[0]) > len(called.Args) {
			return nil, nil, ast.error(ctx, "too many arguments",
				callValues, called.Args)
		}
		args = callValues[0]
	} else {
		if len(callValues) < len(called.Args) {
			return nil, nil, ast.error(ctx, "not enough arguments",
				callValues, called.Args)
		} else if len(callValues) > len(called.Args) {
			return nil, nil, ast.error(ctx, "too many arguments",
				callValues, called.Args)
		} else {
			for idx, ca := range callValues {
				expr := ast.Exprs[idx]
				if len(ca) == 0 {
					return nil, nil, ctx.Errorf(expr, "%s used as value", expr)
				} else if len(ca) > 1 {
					return nil, nil, ctx.Errorf(expr,
						"multiple-value %s in single-value context", expr)
				}
				args = append(args, ca[0])
			}
		}
	}

	// Return block.
	rblock := gen.Block()
	rblock.Bindings = block.Bindings.Clone()

	ctx.PushCompilation(gen.Block(), gen.Block(), rblock, called)

	// Define arguments.
	for idx, arg := range called.Args {
		typeInfo, err := arg.Type.Resolve(NewEnv(block), ctx, gen)
		if err != nil {
			return nil, nil, ctx.Errorf(arg, "invalid argument type: %s", err)
		}
		// Instantiate argument types of template functions.
		if typeInfo.Bits == 0 && !typeInfo.Instantiate(args[idx].Type) {
			return nil, nil, ctx.Errorf(ast.Exprs[idx],
				"cannot use %v as type %s in argument to %s",
				args[idx].Type, typeInfo, called.Name)
		}
		if !ssa.LValueFor(typeInfo, args[idx]) {
			return nil, nil, ctx.Errorf(ast,
				"cannot use %v as type %s in argument to %s",
				args[idx].Type, typeInfo, called.Name)
		}
		a := gen.NewVal(arg.Name, args[idx].Type, ctx.Scope())
		a.PtrInfo = args[idx].PtrInfo
		ctx.Start().Bindings.Set(a, &args[idx])

		block.AddInstr(ssa.NewMovInstr(args[idx], a))
	}
	// This for method calls.
	if called.This != nil {
		typeInfo, err := called.This.Type.Resolve(env, ctx, gen)
		if err != nil {
			return nil, nil, err
		}
		var this ssa.Value
		var bindings *ssa.Bindings

		// First check block bindings.
		b, ok := block.Bindings.Get(ast.Ref.Name.Package)
		if ok {
			bindings = block.Bindings
		} else {
			// Check names in the current package.
			b, ok = ctx.Package.Bindings.Get(ast.Ref.Name.Package)
			if ok {
				bindings = ctx.Package.Bindings
			} else {
				return nil, nil, ctx.Errorf(ast, "undefined: %s",
					ast.Ref.Name.Package)
			}
		}

		// XXX only one level of pointers.
		if typeInfo.Type == types.TPtr && b.Type.Type != types.TPtr {
			// Pointer receiver.
			this = gen.AnonVal(types.Info{
				Type:        types.TPtr,
				Bits:        b.Type.Bits,
				MinBits:     b.Type.Bits,
				ElementType: &b.Type,
			})
			this.PtrInfo = &ssa.PtrInfo{
				Name:          ast.Ref.Name.Package,
				Bindings:      bindings,
				Scope:         b.Scope,
				ContainerType: b.Type,
			}
		} else {
			// Value receiver.
			this = b.Value(block, gen)
		}
		a := gen.NewVal(called.This.Name, typeInfo, ctx.Scope())
		a.PtrInfo = this.PtrInfo
		if a.TypeCompatible(this) == nil {
			return nil, nil, ctx.Errorf(ast,
				"cannot use %v as type %s in receiver to %s",
				this.Type, typeInfo, called.Name)
		}
		ctx.Start().Bindings.Set(a, &this)
		block.AddInstr(ssa.NewMovInstr(this, a))
	}

	// Instantiate called function.
	_, returnValues, err := called.SSA(ctx.Start(), ctx, gen)
	if err != nil {
		return nil, nil, err
	}

	block.SetNext(ctx.Start())

	rblock.Bindings = block.Bindings.Clone()

	ctx.Return().SetNext(rblock)
	block = rblock

	ctx.PopCompilation()

	return block, returnValues, nil
}

func (ast *Call) error(ctx *Codegen, message string, have [][]ssa.Value,
	want []*Variable) error {

	message += fmt.Sprintf(" in call to %s", ast.Ref)
	message += "\n\thave ("
	switch len(have) {
	case 0:

	case 1:
		for i, v := range have[0] {
			if i > 0 {
				message += ", "
			}
			message += v.Type.Type.String()
		}

	default:
		for i, vi := range have {
			if i > 0 {
				message += ", "
			}
			if len(vi) > 0 {
				message += "("
			}
			for j, vj := range vi {
				if j > 0 {
					message += ", "
				}
				message += vj.Type.Type.String()
			}
			if len(vi) > 0 {
				message += ")"
			}
		}
	}
	message += ")\n\twant ("
	for i, v := range want {
		if i > 0 {
			message += ", "
		}
		message += v.Type.String()
	}
	return ctx.Errorf(ast, "%s)", message)
}

// SSA implements the compiler.ast.AST.SSA for return statements.
func (ast *Return) SSA(block *ssa.Block, ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {

	if ctx.Func() == nil {
		return nil, nil, ctx.Errorf(ast, "return outside function")
	}
	if ast.AutoGenerated && len(ctx.Func().Return) > 0 {
		return nil, nil, ctx.Errorf(ast,
			"missing return at the end of function")
	}

	var rValues [][]ssa.Value
	var result []ssa.Value
	var v []ssa.Value
	var err error

	// Compute return values.
	if ctx.Func().NamedReturn && len(ast.Exprs) == 0 {
		for _, ret := range ctx.Func().Return {
			expr := &VariableRef{
				Point: ret.Point,
				Name: Identifier{
					Name: ret.Name,
				},
			}
			block, v, err = expr.SSA(block, ctx, gen)
			if err != nil {
				return nil, nil, err
			}
			rValues = append(rValues, v)
		}
	} else {
		for _, expr := range ast.Exprs {
			block, v, err = expr.SSA(block, ctx, gen)
			if err != nil {
				return nil, nil, err
			}
			rValues = append(rValues, v)
		}
	}
	if len(rValues) == 0 {
		if len(ctx.Func().Return) != 0 {
			return nil, nil, ast.error(ctx, "not enough arguments to return",
				rValues, ctx.Func().Return)
		}
	} else if len(rValues) == 1 {
		if len(rValues[0]) < len(ctx.Func().Return) {
			return nil, nil, ast.error(ctx, "not enough arguments to return",
				rValues, ctx.Func().Return)
		} else if len(rValues[0]) > len(ctx.Func().Return) {
			return nil, nil, ast.error(ctx, "too many aruments to return",
				rValues, ctx.Func().Return)
		}
		result = rValues[0]
	} else {
		if len(rValues) < len(ctx.Func().Return) {
			return nil, nil, ast.error(ctx, "not enough arguments to return",
				rValues, ctx.Func().Return)
		} else if len(rValues) > len(ctx.Func().Return) {
			return nil, nil, ast.error(ctx, "too many aruments to return",
				rValues, ctx.Func().Return)
		} else {
			if len(ast.Exprs) != len(rValues) {
				return nil, nil, ctx.Errorf(ast,
					"invalid number of return values: got %d, expected %d",
					len(ast.Exprs), len(rValues))
			}
			for idx, rv := range rValues {
				expr := ast.Exprs[idx]
				if len(rv) == 0 {
					return nil, nil, ctx.Errorf(expr, "%s used as value", expr)
				} else if len(rv) > 1 {
					return nil, nil, ctx.Errorf(expr,
						"multiple-value %s in single-value context", expr)
				}
				result = append(result, rv[0])
			}
		}
	}

	for idx, r := range ctx.Func().Return {
		typeInfo, err := r.Type.Resolve(NewEnv(block), ctx, gen)
		if err != nil {
			return nil, nil, ctx.Errorf(r, "invalid return type: %s", err)
		}
		// Instantiate result values for template functions.
		if typeInfo.Bits == 0 && !typeInfo.Instantiate(result[idx].Type) {
			return nil, nil, ctx.Errorf(ast,
				"invalid value %v for return value %v",
				result[idx].Type, typeInfo)
		}
		v := gen.NewVal(r.Name, typeInfo, ctx.Scope())
		if result[idx].Type.Type == types.TPtr {
			v.PtrInfo = result[idx].PtrInfo
		}

		// The native() returns undefined values.
		if result[idx].Type.Type == types.TUndefined {
			result[idx].Type.Type = typeInfo.Type
		}

		if !ssa.LValueFor(typeInfo, result[idx]) {
			return nil, nil, ctx.Errorf(ast,
				"invalid value %v for return value %v",
				result[idx].Type, v.Type)
		}

		block.AddInstr(ssa.NewMovInstr(result[idx], v))
		block.Bindings.Set(v, nil)
	}

	block.SetNext(ctx.Return())
	block.Dead = true

	return block, nil, nil
}

func (ast *Return) error(ctx *Codegen, message string, have [][]ssa.Value,
	want []*Variable) error {

	message += "\n\thave ("
	switch len(have) {
	case 0:

	case 1:
		for i, v := range have[0] {
			if i > 0 {
				message += ", "
			}
			message += v.Type.Type.String()
		}

	default:
		for i, vi := range have {
			if i > 0 {
				message += ", "
			}
			if len(vi) > 0 {
				message += "("
			}
			for j, vj := range vi {
				if j > 0 {
					message += ", "
				}
				message += vj.Type.Type.String()
			}
			if len(vi) > 0 {
				message += ")"
			}
		}
	}
	message += ")\n\twant ("
	for i, v := range want {
		if i > 0 {
			message += ", "
		}
		message += v.Type.String()
	}
	return ctx.Errorf(ast, "%s)", message)
}

// SSA implements the compiler.ast.AST.SSA for for statements.
func (ast *For) SSA(block *ssa.Block, ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {

	// Use the same env for the whole for-loop unrolling.
	env := NewEnv(block)

	// Init loop.
	if ast.Init != nil {
		_, ok, err := ast.Init.Eval(env, ctx, gen)
		if err != nil {
			return nil, nil, err
		}
		if !ok {
			return nil, nil, ctx.Errorf(ast.Init,
				"init statement is not compile-time constant: %s", ast.Init)
		}
	}

	// Expand body as long as condition is true.
	for i := 0; ; i++ {
		if i >= gen.Params.MaxLoopUnroll {
			return nil, nil, ctx.Errorf(ast,
				"for-loop unroll limit exceeded: %d", i)
		}
		constVal, ok, err := ast.Cond.Eval(env, ctx, gen)
		if err != nil {
			return nil, nil, err
		}
		if !ok {
			return nil, nil, ctx.Errorf(ast.Cond,
				"condition is not compile-time constant: %s", ast.Cond)
		}
		val, ok := constVal.ConstValue.(bool)
		if !ok {
			return nil, nil, ctx.Errorf(ast.Cond,
				"condition is not boolean expression")
		}
		if !val {
			// Loop completed.
			break
		}
		block.Bindings = env.Bindings

		// Expand block.
		block, _, err = ast.Body.SSA(block, ctx, gen)
		if err != nil {
			return nil, nil, err
		}

		// Increment.
		env = NewEnv(block)
		_, ok, err = ast.Inc.Eval(env, ctx, gen)
		if err != nil {
			return nil, nil, err
		}
		if !ok {
			return nil, nil, ctx.Errorf(ast.Init,
				"increment statement is not compile-time constant: %s", ast.Inc)
		}
	}

	return block, nil, nil
}

func isPowerOf2(ast AST, env *Env, ctx *Codegen, gen *ssa.Generator) (
	uint64, bool) {

	v, ok, err := ast.Eval(env, ctx, gen)
	if err != nil || !ok {
		return 0, false
	}
	switch val := v.ConstValue.(type) {
	case int32:
		i := val
		var count int
		for i > 0 {
			if i&1 == 1 {
				count++
			}
			i >>= 1
		}
		return uint64(val), count <= 1

	case uint64:
		i := val
		var count int
		for i > 0 {
			if i&1 == 1 {
				count++
			}
			i >>= 1
		}
		return val, count <= 1

	default:
		return 0, false
	}
}

// SSA implements the compiler.ast.AST.SSA for binary expressions.
func (ast *Binary) SSA(block *ssa.Block, ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {

	// Check constant folding.
	env := NewEnv(block)
	constVal, ok, err := ast.Eval(env, ctx, gen)
	if err != nil {
		return nil, nil, err
	}
	if ok {
		if ctx.Verbose && debugConstFold {
			fmt.Printf("ConstFold: %v %s %v => %v\n",
				ast.Left, ast.Op, ast.Right, constVal)
		}
		gen.AddConstant(constVal)
		return block, []ssa.Value{constVal}, nil
	}
	lPow2, lConst := isPowerOf2(ast.Left, env, ctx, gen)
	rPow2, rConst := isPowerOf2(ast.Right, env, ctx, gen)
	if lConst || rConst {
		switch ast.Op {
		case BinaryMult:
			// Multiplication is commutative.
			if rConst {
				block, l, err := ast.value(ast.Left, block, ctx, gen)
				if err != nil {
					return nil, nil, err
				}
				return ast.constMult(l, rPow2, block, ctx, gen)
			}
			if lConst {
				block, r, err := ast.value(ast.Right, block, ctx, gen)
				if err != nil {
					return nil, nil, err
				}
				return ast.constMult(r, lPow2, block, ctx, gen)
			}

		case BinaryPlus:
			if rConst && rPow2 == 0 {
				block, l, err := ast.value(ast.Left, block, ctx, gen)
				if err != nil {
					return nil, nil, err
				}
				return block, []ssa.Value{l}, nil
			}
			if lConst && lPow2 == 0 {
				block, r, err := ast.value(ast.Right, block, ctx, gen)
				if err != nil {
					return nil, nil, err
				}
				return block, []ssa.Value{r}, nil
			}

		case BinaryMinus:
			if rConst && rPow2 == 0 {
				block, l, err := ast.value(ast.Left, block, ctx, gen)
				if err != nil {
					return nil, nil, err
				}
				return block, []ssa.Value{l}, nil
			}

		case BinaryLshift, BinaryRshift:

		default:
			if false {
				if lConst {
					fmt.Printf(" - %v %s\n", lPow2, ast.Op)
				}
				if rConst {
					fmt.Printf(" - %s %v\n", ast.Op, rPow2)
				}
			}
		}
	}

	// Check that l and r are of same type.
	block, l, err := ast.value(ast.Left, block, ctx, gen)
	if err != nil {
		return nil, nil, err
	}
	block, r, err := ast.value(ast.Right, block, ctx, gen)
	if err != nil {
		return nil, nil, err
	}

	// Resolve target type.
	var resultType types.Info
	switch ast.Op {
	case BinaryMult, BinaryDiv, BinaryMod, BinaryBand, BinaryBclear,
		BinaryPlus, BinaryMinus, BinaryBor, BinaryBxor:
		superType := l.TypeCompatible(r)
		if superType == nil {
			return nil, nil, ctx.Errorf(ast, "invalid types: %s %s %s",
				l.Type, ast.Op, r.Type)
		}
		resultType = *superType

	case BinaryLshift, BinaryRshift:
		if !l.IntegerLike() || !r.IntegerLike() {
			return nil, nil, ctx.Errorf(ast, "invalid types: %s %s %s",
				l.Type, ast.Op, r.Type)
		}
		resultType = l.Type

	case BinaryLt, BinaryLe, BinaryGt, BinaryGe, BinaryEq, BinaryNeq,
		BinaryAnd, BinaryOr:
		resultType = types.BoolType()

	default:
		fmt.Printf("%s %s %s\n", l, ast.Op, r)
		return nil, nil, ctx.Errorf(ast, "Binary.SSA: '%s' not implemented yet",
			ast.Op)
	}
	t := gen.AnonVal(resultType)

	var instr ssa.Instr
	switch ast.Op {
	case BinaryMult:
		instr, err = ssa.NewMultInstr(l.Type, l, r, t)
	case BinaryDiv:
		instr, err = ssa.NewDivInstr(l.Type, l, r, t)
	case BinaryMod:
		instr, err = ssa.NewModInstr(l.Type, l, r, t)
	case BinaryLshift:
		instr = ssa.NewLshiftInstr(l, r, t)
	case BinaryRshift:
		if l.Type.Type == types.TInt {
			// Use sign-extension version srshift.
			instr = ssa.NewSrshiftInstr(l, r, t)
		} else {
			instr = ssa.NewRshiftInstr(l, r, t)
		}
	case BinaryBand:
		instr, err = ssa.NewBandInstr(l, r, t)
	case BinaryBclear:
		instr, err = ssa.NewBclrInstr(l, r, t)
	case BinaryPlus:
		instr, err = ssa.NewAddInstr(l.Type, l, r, t)
	case BinaryMinus:
		instr, err = ssa.NewSubInstr(l.Type, l, r, t)
	case BinaryBor:
		instr, err = ssa.NewBorInstr(l, r, t)
	case BinaryBxor:
		instr, err = ssa.NewBxorInstr(l, r, t)
	case BinaryEq:
		instr, err = ssa.NewEqInstr(l, r, t)
	case BinaryNeq:
		instr, err = ssa.NewNeqInstr(l, r, t)
	case BinaryLt:
		instr, err = ssa.NewLtInstr(l.Type, l, r, t)
	case BinaryLe:
		instr, err = ssa.NewLeInstr(l.Type, l, r, t)
	case BinaryGt:
		instr, err = ssa.NewGtInstr(l.Type, l, r, t)
	case BinaryGe:
		instr, err = ssa.NewGeInstr(l.Type, l, r, t)
	case BinaryAnd:
		instr, err = ssa.NewAndInstr(l, r, t)
	case BinaryOr:
		instr, err = ssa.NewOrInstr(l, r, t)
	default:
		fmt.Printf("%s %s %s\n", l, ast.Op, r)
		return nil, nil, ctx.Errorf(ast, "Binary.SSA: '%s' not implemented yet",
			ast.Op)
	}
	if err != nil {
		return nil, nil, err
	}

	block.AddInstr(instr)

	return block, []ssa.Value{t}, nil
}

func (ast *Binary) value(val AST, block *ssa.Block, ctx *Codegen,
	gen *ssa.Generator) (*ssa.Block, ssa.Value, error) {

	block, arr, err := val.SSA(block, ctx, gen)
	if err != nil {
		return nil, ssa.Value{}, err
	}
	if len(arr) == 0 {
		return nil, ssa.Value{}, ctx.Errorf(val, "%s used as value", val)
	}
	if len(arr) > 1 {
		return nil, ssa.Value{}, ctx.Errorf(val,
			"multiple-value %s in single-value context", val)
	}
	return block, arr[0], nil
}

func (ast *Binary) constMult(v ssa.Value, c uint64, block *ssa.Block,
	ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {

	if c == 0 {
		r := gen.Constant(c, v.Type)
		gen.AddConstant(r)
		return block, []ssa.Value{r}, nil
	} else if c == 1 {
		return block, []ssa.Value{v}, nil
	}

	var count int
	for c > 1 {
		count++
		c >>= 1
	}

	shift := gen.Constant(int32(count), types.Int32)

	t := gen.AnonVal(v.Type)
	instr := ssa.NewLshiftInstr(v, shift, t)
	block.AddInstr(instr)

	return block, []ssa.Value{t}, nil
}

// SSA implements the compiler.ast.AST.SSA for unary expressions.
func (ast *Unary) SSA(block *ssa.Block, ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {

	constVal, ok, err := ast.Eval(NewEnv(block), ctx, gen)
	if err != nil {
		return nil, nil, err
	}
	if ok {
		if ctx.Verbose && debugConstFold {
			fmt.Printf("ConstFold: %v => %v\n", ast, constVal)
		}
		gen.AddConstant(constVal)
		return block, []ssa.Value{constVal}, nil
	}

	switch ast.Type {
	case UnaryMinus:
		block, exprs, err := ast.Expr.SSA(block, ctx, gen)
		if err != nil {
			return nil, nil, err
		}
		if len(exprs) != 1 {
			return nil, nil, ctx.Errorf(ast,
				"multiple-value %s used in single-value context", ast.Expr)
		}
		expr := exprs[0]

		t := gen.AnonVal(expr.Type)
		switch expr.Type.Type {
		case types.TInt, types.TUint:
			zero := gen.Constant(int32(0), types.Info{
				Type:    types.TInt,
				MinBits: 1,
				Bits:    1,
			})
			gen.AddConstant(zero)
			instr, err := ssa.NewSubInstr(expr.Type, zero, expr, t)
			if err != nil {
				return nil, nil, err
			}
			block.AddInstr(instr)
			return block, []ssa.Value{t}, nil

		default:
			return nil, nil, ctx.Errorf(ast, "%s not supported", ast)
		}

	case UnaryAddr:
		switch v := ast.Expr.(type) {
		case *VariableRef:
			var bindings *ssa.Bindings
			var containerType types.Info
			var elementType types.Info
			var elementOffset types.Size
			var ptrName string
			var ptrScope ssa.Scope

			if len(v.Name.Package) == 0 {
				// Identifier
				ptrName = v.Name.Name

				// First check block bindings.
				b, ok := block.Bindings.Get(v.Name.Name)
				if ok {
					bindings = block.Bindings
				} else {
					// Check names in the current package.
					b, ok = ctx.Package.Bindings.Get(v.Name.Name)
					if ok {
						bindings = ctx.Package.Bindings
					} else {
						return nil, nil,
							ctx.Errorf(ast, "undefined: %s", v.Name)
					}
				}
				containerType = b.Type
				elementType = b.Type
				elementOffset = 0
				ptrScope = b.Scope
			} else {
				// Qualified name.

				// Check block bindings.
				b, ok := block.Bindings.Get(v.Name.Package)
				if ok {
					bindings = block.Bindings
				} else {
					// Check names in the current package.
					b, ok = ctx.Package.Bindings.Get(v.Name.Package)
					if ok {
						bindings = ctx.Package.Bindings
					} else {
						return nil, nil,
							ctx.Errorf(ast, "undefined: %s", v.Name)
					}
				}
				containerType = b.Type
				bValue := b.Value(block, gen)

				var it types.Info
				if bValue.Type.Type == types.TPtr {
					it = *bValue.Type.ElementType
				} else {
					it = bValue.Type
				}

				elementType, elementOffset, err = lookupElement(ctx, ast,
					it, v.Name.Name)
				if err != nil {
					return nil, nil, err
				}
				if bValue.Type.Type == types.TPtr {
					ptrName = bValue.PtrInfo.Name
					ptrScope = bValue.PtrInfo.Scope
					bindings = bValue.PtrInfo.Bindings
					containerType = bValue.PtrInfo.ContainerType
				} else {
					ptrScope = b.Scope
					ptrName = v.Name.Package
				}
			}
			t := gen.AnonVal(types.Info{
				Type:        types.TPtr,
				Bits:        elementType.Bits,
				MinBits:     elementType.Bits,
				ElementType: &elementType,
			})
			t.PtrInfo = &ssa.PtrInfo{
				Name:          ptrName,
				Scope:         ptrScope,
				Bindings:      bindings,
				ContainerType: containerType,
				Offset:        elementOffset,
			}
			return block, []ssa.Value{t}, nil

		case *Index:
			lrv, ptrType, offset, err := ast.addrIndex(block, ctx, gen, v)
			if err != nil {
				return nil, nil, err
			}
			t := gen.AnonVal(types.Info{
				Type:        types.TPtr,
				Bits:        ptrType.Bits,
				MinBits:     ptrType.Bits,
				ElementType: ptrType,
			})
			t.PtrInfo = lrv.BasePtrInfo()
			t.PtrInfo.Offset += offset
			return block, []ssa.Value{t}, nil

		default:
			return nil, nil, ctx.Errorf(ast, "Unary.SSA: '%T' not supported", v)
		}

	default:
		return nil, nil, ctx.Errorf(ast, "Unary.SSA not implemented yet: %v",
			ast)
	}
}

func (ast *Unary) addrIndex(block *ssa.Block, ctx *Codegen, gen *ssa.Generator,
	index *Index) (
	lrv *LRValue, ptrType *types.Info, offset types.Size, err error) {

	switch indexed := index.Expr.(type) {
	case *VariableRef:
		lrv, _, err = ctx.LookupVar(block, gen, block.Bindings,
			indexed)
		if err != nil {
			return
		}
		vt := lrv.ValueType()
		if vt.Type != types.TArray {
			return nil, nil, 0, ctx.Errorf(indexed,
				"invalid operation: %s (type %s does not support indexing)",
				index, ptrType)
		}
		ptrType = &vt

	case *Index:
		lrv, ptrType, offset, err = ast.addrIndex(block, ctx, gen, indexed)

	default:
		return nil, nil, 0,
			ctx.Errorf(ast, "&%s not supported (%T)", index, indexed)
	}

	var indices []ssa.Value
	block, indices, err = index.Index.SSA(block, ctx, gen)
	if err != nil {
		return
	}
	if len(indices) != 1 {
		return nil, nil, 0, ctx.Errorf(index, "invalid index")
	}
	var ival types.Size
	ival, err = indices[0].ConstInt()
	if err != nil {
		err = ctx.Errorf(index.Index, "%s", err)
		return
	}
	if ival < 0 || ival >= ptrType.ArraySize {
		return nil, nil, 0, ctx.Errorf(index.Index,
			"invalid array index %d (out of bounds for %d-element string)",
			ival, ptrType.ArraySize)
	}
	return lrv, ptrType.ElementType, offset + ival*ptrType.ElementType.Bits, nil
}

func lookupElement(ctx *Codegen, loc utils.Locator, t types.Info, name string) (
	types.Info, types.Size, error) {

	switch t.Type {
	case types.TStruct:
		var offset types.Size
		for _, field := range t.Struct {
			if field.Name == name {
				return field.Type, offset, nil
			}
			offset += field.Type.Bits
		}
		return types.Undefined, 0, ctx.Errorf(loc,
			"%s undefined (%s has no field of method %s)", name, t, name)

	default:
		return types.Undefined, 0, ctx.Errorf(loc,
			"%s undefined (%s has no field of method %s)", name, t, name)
	}
}

// SSA implements the compiler.ast.AST.SSA for slice expressions.
func (ast *Slice) SSA(block *ssa.Block, ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {

	block, exprs, err := ast.Expr.SSA(block, ctx, gen)
	if err != nil {
		return nil, nil, err
	}
	if len(exprs) != 1 {
		return nil, nil, ctx.Errorf(ast, "invalid expression")
	}
	expr := exprs[0]
	elementType := expr.ElementType()

	var elementSize types.Size
	var elementCount types.Size

	switch elementType.Type {
	case types.TInt, types.TUint:
		elementSize = 1
		elementCount = elementType.Bits

	case types.TArray:
		elementSize = elementType.ElementType.Bits
		elementCount = elementType.ArraySize

	default:
		return nil, nil, ctx.Errorf(ast, "slice of %s not supported",
			expr.Type.Type)
	}

	var val []ssa.Value
	var from types.Size
	if ast.From == nil {
		from = 0
	} else {
		block, val, err = ast.From.SSA(block, ctx, gen)
		if err != nil {
			return nil, nil, err
		}
		if len(val) != 1 {
			return nil, nil, ctx.Errorf(ast.From, "invalid from index")
		}
		from, err = val[0].ConstInt()
		if err != nil {
			return nil, nil, ctx.Errorf(ast.From, "%s", err)
		}
	}
	var to types.Size
	if ast.To == nil {
		to = elementCount
	} else {
		block, val, err = ast.To.SSA(block, ctx, gen)
		if err != nil {
			return nil, nil, err
		}
		if len(val) != 1 {
			return nil, nil, ctx.Errorf(ast.To, "invalid to index")
		}
		to, err = val[0].ConstInt()
		if err != nil {
			return nil, nil, ctx.Errorf(ast.To, "%s", err)
		}
	}
	if from >= elementCount || from >= to {
		return nil, nil, ctx.Errorf(ast, "slice bounds out of range [%d:%d]",
			from, to)
	}

	fromConst := gen.Constant(int32(from*elementSize), types.Uint32)
	toConst := gen.Constant(int32(to*elementSize), types.Uint32)

	bits := (to - from) * elementSize

	var t ssa.Value

	if expr.Type.Type == types.TPtr {
		if elementType.Type == types.TArray {

			ptrInfo := expr.PtrInfo
			ptrInfo.Offset += from * elementSize

			et := elementType
			et.ID = 0
			et.ArraySize = to - from

			ti := types.Info{
				Type:        types.TPtr,
				Bits:        bits,
				MinBits:     bits,
				ElementType: &et,
			}
			t = gen.AnonVal(ti)
			t.PtrInfo = ptrInfo
		} else {
			return nil, nil, ctx.Errorf(ast, "slice of %s not supported",
				expr.Type)
		}
	} else {
		ti := types.Info{
			Type:    elementType.Type,
			Bits:    bits,
			MinBits: bits,
		}
		if elementType.Type == types.TArray {
			ti.ElementType = elementType.ElementType
			ti.ArraySize = ti.Bits / ti.ElementType.Bits
		}

		t = gen.AnonVal(ti)
	}
	block.AddInstr(ssa.NewSliceInstr(expr, fromConst, toConst, t))

	return block, []ssa.Value{t}, nil
}

// SSA implements the compiler.ast.AST.SSA for index expressions.
func (ast *Index) SSA(block *ssa.Block, ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {

	block, exprs, err := ast.Expr.SSA(block, ctx, gen)
	if err != nil {
		return nil, nil, err
	}
	if len(exprs) != 1 {
		return nil, nil, ctx.Errorf(ast, "invalid expression")
	}
	expr := exprs[0]

	block, val, err := ast.Index.SSA(block, ctx, gen)
	if err != nil {
		return nil, nil, err
	}
	if len(val) != 1 {
		return nil, nil, ctx.Errorf(ast.Index, "invalid index")
	}
	if val[0].Const {
		return ast.constIndex(block, ctx, gen, expr, val[0])
	}
	return ast.index(block, ctx, gen, expr, val[0])
}

func (ast *Index) constIndex(block *ssa.Block, ctx *Codegen, gen *ssa.Generator,
	expr, ival ssa.Value) (*ssa.Block, []ssa.Value, error) {

	index, err := ival.ConstInt()
	if err != nil {
		return nil, nil, ctx.Errorf(ast.Index, "%s", err)
	}

	var it types.Info
	var ptrInfo ssa.PtrInfo
	if expr.Type.Type == types.TPtr {
		it = *expr.Type.ElementType
		ptrInfo = *expr.PtrInfo
		b, ok := ptrInfo.Bindings.Get(ptrInfo.Name)
		if !ok {
			return nil, nil, ctx.Errorf(ast.Index, "undefined: %s",
				ptrInfo.Name)
		}
		expr = b.Value(block, gen)
	} else {
		it = expr.Type
	}

	switch it.Type {
	case types.TString:
		length := it.Bits / types.ByteBits
		if index < 0 || index >= length {
			return nil, nil, ctx.Errorf(ast.Index,
				"invalid array index %d (out of bounds for %d-element string)",
				index, length)
		}
		from := int32(index*types.ByteBits + ptrInfo.Offset)
		to := int32((index+1)*types.ByteBits + ptrInfo.Offset)

		fromConst := gen.Constant(from, types.Uint32)
		toConst := gen.Constant(to, types.Uint32)

		indexType := types.Info{
			Type:    types.TUint,
			Bits:    types.ByteBits,
			MinBits: types.ByteBits,
		}

		t := gen.AnonVal(indexType)
		block.AddInstr(ssa.NewSliceInstr(expr, fromConst, toConst, t))

		return block, []ssa.Value{t}, nil

	case types.TArray:
		if index < 0 || index >= it.ArraySize {
			return nil, nil, ctx.Errorf(ast.Index,
				"invalid array index %d (out of bounds for %d-element array)",
				index, it.ArraySize)
		}
		from := int32(index*it.ElementType.Bits + ptrInfo.Offset)
		to := int32((index+1)*it.ElementType.Bits + ptrInfo.Offset)

		fromConst := gen.Constant(from, types.Uint32)
		toConst := gen.Constant(to, types.Uint32)

		t := gen.AnonVal(*it.ElementType)
		block.AddInstr(ssa.NewSliceInstr(expr, fromConst, toConst, t))

		return block, []ssa.Value{t}, nil

	default:
		return nil, nil, ctx.Errorf(ast,
			"invalid operation: %s[%d] (type %s does not support indexing)",
			ast.Expr, index, expr.Type)
	}
}

func (ast *Index) index(block *ssa.Block, ctx *Codegen, gen *ssa.Generator,
	expr, index ssa.Value) (*ssa.Block, []ssa.Value, error) {

	var it types.Info
	var ptrInfo ssa.PtrInfo
	if expr.Type.Type == types.TPtr {
		it = *expr.Type.ElementType
		ptrInfo = *expr.PtrInfo
		b, ok := ptrInfo.Bindings.Get(ptrInfo.Name)
		if !ok {
			return nil, nil, ctx.Errorf(ast.Index, "undefined: %s",
				ptrInfo.Name)
		}
		expr = b.Value(block, gen)
	} else {
		it = expr.Type
	}

	switch it.Type {
	case types.TArray:
		offset := gen.Constant(int32(ptrInfo.Offset), types.Uint32)
		t := gen.AnonVal(*it.ElementType)
		block.AddInstr(ssa.NewIndexInstr(expr, offset, index, t))
		return block, []ssa.Value{t}, nil

	default:
		return nil, nil, ctx.Errorf(ast,
			"invalid operation: %s[%v] (type %s does not support non-cost indexing)",
			ast.Expr, index, expr.Type)
	}
}

// SSA implements the compiler.ast.AST.SSA for variable references.
func (ast *VariableRef) SSA(block *ssa.Block, ctx *Codegen,
	gen *ssa.Generator) (*ssa.Block, []ssa.Value, error) {

	lrv, _, err := ctx.LookupVar(block, gen, block.Bindings, ast)
	if err != nil {
		return nil, nil, err
	}

	value := lrv.RValue()
	if value.Const {
		gen.AddConstant(value)
	}

	return block, []ssa.Value{value}, nil
}

// SSA implements the compiler.ast.AST.SSA for constant values.
func (ast *BasicLit) SSA(block *ssa.Block, ctx *Codegen,
	gen *ssa.Generator) (*ssa.Block, []ssa.Value, error) {

	v := gen.Constant(ast.Value, types.Undefined)
	gen.AddConstant(v)

	return block, []ssa.Value{v}, nil
}

// SSA implements the compiler.ast.AST.SSA for constant values.
func (ast *CompositeLit) SSA(block *ssa.Block, ctx *Codegen,
	gen *ssa.Generator) (*ssa.Block, []ssa.Value, error) {
	return nil, nil, fmt.Errorf("CompositeLit.SSA not implemented yet")
}

// SSA implements the compiler.ast.AST.SSA for the builtin function make.
func (ast *Make) SSA(block *ssa.Block, ctx *Codegen, gen *ssa.Generator) (
	*ssa.Block, []ssa.Value, error) {
	return nil, nil, fmt.Errorf("Make.SSA not supported")
}
