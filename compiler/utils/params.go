//
// Copyright (c) 2020-2025 Markku Rossi
//
// All rights reserved.
//

package utils

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"regexp"
	"sort"
	"strconv"
)

// Params specify compiler parameters.
type Params struct {
	Verbose       bool
	Diagnostics   bool
	SSAOut        io.WriteCloser
	SSADotOut     io.WriteCloser
	MPCLCErrorLoc bool

	// PkgPath defines additional directories to search for imported
	// packages.
	PkgPath []string

	// MaxLoopUnroll specifies the upper limit for loop unrolling.
	MaxLoopUnroll int

	NoCircCompile bool
	CircOut       io.WriteCloser
	CircDotOut    io.WriteCloser
	CircSvgOut    io.WriteCloser
	CircFormat    string

	CircMultArrayTreshold int

	OptPruneGates bool

	BenchmarkCompile bool

	// SymbolIDs contain the mappings from the interned symbols to
	// their values. You must persist these in the application code if
	// you want to maintain the mappings across different compiler
	// invocations.
	SymbolIDs map[string]int
}

// NewParams returns new compiler params object, initialized with the
// default values.
func NewParams() *Params {
	return &Params{
		MaxLoopUnroll: 0x20000,
		SymbolIDs:     make(map[string]int),
	}
}

// Close closes all open resources.
func (p *Params) Close() {
	if p.SSAOut != nil {
		p.SSAOut.Close()
		p.SSAOut = nil
	}
	if p.SSADotOut != nil {
		p.SSADotOut.Close()
		p.SSADotOut = nil
	}
	if p.CircOut != nil {
		p.CircOut.Close()
		p.CircOut = nil
	}
	if p.CircDotOut != nil {
		p.CircDotOut.Close()
		p.CircDotOut = nil
	}
	if p.CircSvgOut != nil {
		p.CircSvgOut.Close()
		p.CircSvgOut = nil
	}
}

var (
	reConstStart = regexp.MustCompilePOSIX(`^const[[:space:]]+\([[:space:]]*$`)
	reConst      = regexp.MustCompilePOSIX(
		`[[:space:]]*([[:^space:]]+)[[:space:]]*=[[:space:]]*([[:digit:]]+)[[:space:]]*$`)
	reConstEnd = regexp.MustCompilePOSIX(`^[[:space:]]*\)[[:space:]]*$`)
)

// LoadSymbolIDs loads the symbol IDs from file.
func (p *Params) LoadSymbolIDs(file string) error {
	f, err := os.Open(file)
	if err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return err
	}
	defer f.Close()

	var inConstBlock bool

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()

		if inConstBlock {
			m := reConst.FindStringSubmatch(line)
			if m != nil {
				val, err := strconv.Atoi(m[2])
				if err != nil {
					return err
				}
				p.SymbolIDs[m[1]] = val
			} else {
				m = reConstEnd.FindStringSubmatch(line)
				if m != nil {
					inConstBlock = false
				}
			}
		} else {
			m := reConstStart.FindStringSubmatch(line)
			if m != nil {
				inConstBlock = true
			}
		}
	}

	return scanner.Err()
}

// SaveSymbolIDs saves the symbol IDs to file. The file is a valid
// MPCL source file in package pkg.
func (p *Params) SaveSymbolIDs(pkg, file string) error {
	f, err := os.Create(file)
	if err != nil {
		return err
	}
	defer f.Close()
	fmt.Fprintf(f, `// -*- go -*-
//
// Code generated by MPCL compiler. DO NOT EDIT.
//

package %s

// Interned symbols.
const (
`,
		pkg)

	var keys []string
	var max int
	for key := range p.SymbolIDs {
		keys = append(keys, key)
		if len(key) > max {
			max = len(key)
		}
	}
	sort.Strings(keys)
	for _, key := range keys {
		fmt.Fprintf(f, "\t%s", key)
		for i := len(key); i < max; i++ {
			fmt.Fprint(f, " ")
		}
		fmt.Fprintf(f, " = %v\n", p.SymbolIDs[key])
	}
	fmt.Fprintln(f, ")")

	return nil
}
